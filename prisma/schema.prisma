generator client {
  provider = "prisma-client-js"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

generator erd {
  provider = "prisma-erd-generator"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "foreignKeys"
}

model Account {
  id       Bytes       @id @db.Binary(16)
  email    String      @unique @db.VarChar(100)
  password String      @db.VarChar(100)
  role     AccountRole
  name     String      @db.VarChar(255)

  payment         Payment?
  seats           PickSeat[]
  ratings         Rating[]
  comments        Comment[]
  manager_account ManagerAccount?
  user_account    UserAccount?

  @@map("Account")
}

model UserAccount {
  id Bytes @unique @db.Binary(16)

  account Account @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("UserAccount")
}

model ManagerAccount {
  id Bytes @id @db.Binary(16)

  account  Account             @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinemas  CinemasOnManagers[] // Managers manage cinemas
  items    Item[] // Managers create items (items or combos) for cinema
  films    Film[] // Managers create films
  performs Perform[] // Managers create performs
  layouts  CinemaLayout[] // Managers create cinema layouts

  @@map("ManagerAccount")
}

model Item {
  id                 Bytes  @id @db.Binary(16)
  parent_id          Bytes? @db.Binary(16) // If this item is a combo, this field will be filled
  manager_id         Bytes  @db.Binary(16) // Which manager create this item?
  cinema_provider_id Bytes  @db.Binary(16) // Create for which cinema provider?
  name               String @db.VarChar(255)
  amount             Float  @db.Float
  discount           Float  @default(0) @db.Float

  parent          Item?             @relation("NestedItemSystem", fields: [parent_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  manager         ManagerAccount    @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinema_provider CinemaProvider    @relation(fields: [cinema_provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  items           Item[]            @relation("NestedItemSystem")
  payments        ItemsOnPayments[]

  @@map("Item")
}

model Tag {
  name String @id @db.VarChar(255)
 
  films FilmsOnTags[]

  @@map("Tag")
}

model Film {
  id                 Bytes    @id @db.Binary(16)
  manager_id         Bytes    @db.Binary(16) // Which manager create this film?
  cinema_provider_id Bytes    @db.Binary(16) // Which cinema provider provide this film?
  title              String   @db.VarChar(255)
  director           String   @db.VarChar(50)
  description        String   @db.Text
  release_date       DateTime @db.Timestamp(0)
  country            String   @db.VarChar(50)
  restrict_age       Int      @default(0) @db.UnsignedTinyInt
  duration           Int      @db.UnsignedSmallInt
  picture_url        String   @db.VarChar(2083)
  background_url     String   @db.VarChar(2083)
  trailer_url        String   @db.VarChar(2083)
  language           String   @db.VarChar(50)

  manager         ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinema_provider CinemaProvider @relation(fields: [cinema_provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ratings         Rating[]       @relation("RatingToFilm")
  tags            FilmsOnTags[]
  comments        Comment[]      @relation("CommentToFilm")
  performs        Perform[]

  @@map("Film")
}

model PickSeat {
  id         Bytes  @id @db.Binary(16)
  account_id Bytes  @db.Binary(16) // Which account pick this seat?
  perform_id Bytes  @db.Binary(16) // Which perform this seat belong to? We can use the cinema_room to identify the perform but we want to add some casade delete/update here from perform (if perform is deleted, all picked seat will be deleted)
  code       String @db.VarChar(50)

  account Account @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  perform Perform @relation(fields: [perform_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // Comment because we will handle seat & payment at application layer, not database
  @@unique([account_id, perform_id, code]) // Same seat can't be picked twice by same user
  @@map("PickSeat")
}

model Perform {
  id             Bytes                @id @db.Binary(16)
  manager_id     Bytes                @db.Binary(16) // Which manager create this perform?
  film_id        Bytes                @db.Binary(16) // Which film this perform show?
  cinema_room_id Bytes                @db.Binary(16) // Which cinema room this perform show?
  start_time     DateTime             @db.Timestamp(0)
  end_time       DateTime             @db.Timestamp(0) // !Must implement auto remove row when end_time is passed (on application or database layer) to trigger casade delete to PickSeat
  translate_type PerformTranslateType @default(value: NONE)
  view_type      PerformViewType      @default(value: V2D)
  price          Float                @db.Float

  manager  ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  film     Film           @relation(fields: [film_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  room     CinemaRoom     @relation(fields: [cinema_room_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  payments Payment[]
  seats    PickSeat[]

  @@map("Perform")
}

model Payment {
  id           Bytes         @id @db.Binary(16)
  account_id   Bytes         @unique @db.Binary(16) // unique because one account only have one payment (safe)
  perform_id   Bytes         @db.Binary(16) // Which perform this payment belong to? Morelike "the ticket" we bought
  date_created DateTime      @default(now()) @db.Timestamp(0)
  date_expired DateTime      @db.Timestamp(0)
  status       PaymentStatus @default(value: PENDING)

  account Account           @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  perform Perform           @relation(fields: [perform_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  items   ItemsOnPayments[]

  @@map("Payment")
}

model CinemaProvider {
  id             Bytes  @id @db.Binary(16)
  name           String @db.VarChar(50)
  logo_url       String @db.VarChar(2083)
  background_url String @db.VarChar(2083)

  ratings  Rating[]  @relation("RatingToCinemaProvider")
  comments Comment[] @relation("CommentToCinemaProvider")
  cinemas  Cinema[]
  items    Item[] // Cinema provider can create items for all cinemas
  films    Film[] // Cinema provider can create films for all cinemas

  @@map("CinemaProvider")
}

model Cinema {
  id          Bytes  @id @db.Binary(16)
  name        String @db.VarChar(50)
  provider_id Bytes  @db.Binary(16)
  manager_id  Bytes  @db.Binary(16)
  address     String @db.VarChar(255)

  provider CinemaProvider      @relation(fields: [provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  rooms    CinemaRoom[]
  managers CinemasOnManagers[]

  @@map("Cinema")
}

model CinemaRoom {
  id               Bytes          @id @db.Binary(16)
  name             String         @db.VarChar(255)
  type             CinemaRoomType
  cinema_id        Bytes          @db.Binary(16)
  cinema_layout_id Bytes          @db.Binary(16)

  cinema        Cinema       @relation(fields: [cinema_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinema_layout CinemaLayout @relation(fields: [cinema_layout_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  performs      Perform[]

  @@map("CinemaRoom")
}

model CinemaLayout {
  id         Bytes            @id @db.Binary(16)
  manager_id Bytes            @db.Binary(16) // Who create this layout?
  type       CinemaLayoutType
  data       String           @db.Text

  cinema_rooms CinemaRoom[]
  manager      ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("CinemaLayout")
}

model Comment {
  id         Bytes       @id @db.Binary(16)
  parent_id  Bytes?      @db.Binary(16) // If this comment is a reply, this field will be filled
  account_id Bytes       @db.Binary(16)
  dest_id    Bytes       @db.Binary(16)
  body       String      @db.VarChar(300)
  type       CommentType

  parent               Comment?       @relation("NestedCommentSystem", fields: [dest_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  account              Account        @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ratings              Rating[]       @relation("RatingToComment")
  comments             Comment[]      @relation("NestedCommentSystem") // Nested comment
  dest_cinema_provider CinemaProvider @relation("CommentToCinemaProvider", map: "Comment_dest_cinema_provider_fkey", fields: [dest_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_film            Film           @relation("CommentToFilm", map: "Comment_dest_film_fkey", fields: [dest_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("Comment")
}

model Rating {
  id         Bytes      @id @db.Binary(16)
  account_id Bytes      @db.Binary(16)
  dest_id    Bytes      @db.Binary(16)
  type       RatingType
  score      Float      @db.Float

  account              Account        @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_cinema_provider CinemaProvider @relation("RatingToCinemaProvider", map: "Rating_dest_cinema_provider_fkey", fields: [dest_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_film            Film           @relation("RatingToFilm", map: "Rating_dest_film_fkey", fields: [dest_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_comment         Comment        @relation("RatingToComment", map: "Rating_dest_comment_fkey", fields: [dest_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([account_id, dest_id]) // Same account can only rate one time to same destination
}

model FilmsOnTags {
  film_id Bytes @db.Binary(16)
  tag_id  String @db.VarChar(255)

  film Film @relation(fields: [film_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  tag  Tag  @relation(fields: [tag_id], references: [name], onDelete: Cascade, onUpdate: Cascade)

  @@id([film_id, tag_id])
  @@map("_FilmTag")
}

model ItemsOnPayments {
  item_id    Bytes @db.Binary(16)
  payment_id Bytes @db.Binary(16)

  item    Item    @relation(fields: [item_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  payment Payment @relation(fields: [payment_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([item_id, payment_id])
  @@map("_ItemPayment")
}

model CinemasOnManagers {
  cinema_id  Bytes @db.Binary(16)
  manager_id Bytes @db.Binary(16)

  cinema  Cinema         @relation(fields: [cinema_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  manager ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([cinema_id, manager_id])
  @@map("_CinemaManager")
}

enum CinemaRoomType {
  NORMAL
  VIP
  DELUXE
}

enum CinemaLayoutType {
  RECTANGLE
  DYNAMIC
}

enum CommentType {
  FILM
  ACCOUNT
  COMMENT
}

enum AccountRole {
  USER
  MANAGER
  SUPERADMIN
}

enum PaymentStatus {
  PENDING
  RESOLVED
}

enum PerformTranslateType {
  SUBTITLE
  DUBBING
  NONE
}

enum PerformViewType {
  V2D
  V3D
  IMAX
}

enum RatingType {
  FILM
  CINEMA
  COMMENT
}
