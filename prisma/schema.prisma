generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["tracing"]
}

generator dbml {
  provider = "prisma-dbml-generator"
}

generator erd {
  provider = "prisma-erd-generator"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "foreignKeys"
}

model Account {
  id       Bytes       @id @db.Binary(16)
  email    String      @unique @db.VarChar(100)
  password String      @db.VarChar(100)
  role     AccountRole
  name     String      @db.VarChar(255)

  payment         Payment[]
  pickseats       PickSeat[]
  ratings         Rating[]
  comments        Comment[]
  manager_account ManagerAccount?
  user_account    UserAccount?

  @@map("account")
}

model UserAccount {
  id Bytes @unique @db.Binary(16)

  account Account @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("useraccount")
}

model ManagerAccount {
  id Bytes @id @db.Binary(16)

  account  Account             @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinemas  CinemasOnManagers[] // Managers manage cinemas
  items    Item[] // Managers create items (items or combos) for cinema
  films    Film[] // Managers create films
  performs Perform[] // Managers create performs
  layouts  CinemaLayout[] // Managers create cinema layouts

  @@map("manageraccount")
}

model Item {
  id                 Bytes   @id @db.Binary(16)
  parent_id          Bytes?  @db.Binary(16) // If this item is a combo, this field will be filled
  manager_id         Bytes   @db.Binary(16) // Which manager create this item?
  cinema_provider_id Bytes   @db.Binary(16) // Create for which cinema provider?
  name               String  @db.VarChar(255)
  price              Decimal @db.Decimal(10, 2)
  discount           Float   @default(0) @db.Float

  parent          Item?             @relation("NestedItemSystem", fields: [parent_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  manager         ManagerAccount    @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinema_provider CinemaProvider    @relation(fields: [cinema_provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  items           Item[]            @relation("NestedItemSystem")
  payments        ItemsOnPayments[]

  @@map("item")
}

model Tag {
  name String @id @db.VarChar(255)

  films FilmsOnTags[]

  @@map("tag")
}

model Film {
  id                 Bytes    @id @db.Binary(16)
  manager_id         Bytes    @db.Binary(16) // Which manager create this film?
  cinema_provider_id Bytes    @db.Binary(16) // Which cinema provider provide this film?
  title              String   @db.VarChar(255)
  director           String   @db.VarChar(50)
  description        String   @db.Text
  release_date       DateTime @db.Timestamp(0)
  country            String   @db.VarChar(50)
  restrict_age       Int      @default(0) @db.Int
  duration           Int      @db.Int
  picture_url        String   @db.VarChar(2083)
  background_url     String   @db.VarChar(2083)
  trailer_url        String   @db.VarChar(2083)
  language           String   @db.VarChar(50)

  manager         ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinema_provider CinemaProvider @relation(fields: [cinema_provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ratings         Rating[]       @relation("RatingToFilm")
  comments        Comment[]      @relation("CommentToFilm")
  tags            FilmsOnTags[]
  performs        Perform[]

  @@map("film")
}

model PickSeat {
  id             Bytes @id @db.Binary(16)
  account_id     Bytes @db.Binary(16) // Which account pick this seat?
  perform_id     Bytes @db.Binary(16) // Which perform this seat belong to? We can use the cinema_room to identify but the cinema_room is static so we have to clean pickseats mannually after perform end
  layout_seat_id Bytes @db.Binary(16) // Which seat this account pick?

  account     Account          @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  perform     Perform          @relation(fields: [perform_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  layout_seat CinemaLayoutSeat @relation(fields: [layout_seat_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([account_id, perform_id, layout_seat_id]) // One account cannot pick same seat, one seat can be picked by many people so we dont unique [perform_id, code] here
  @@map("pickseat")
}

model Perform {
  id             Bytes                @id @db.Binary(16)
  manager_id     Bytes                @db.Binary(16) // Which manager create this perform?
  film_id        Bytes                @db.Binary(16) // Which film this perform show?
  cinema_room_id Bytes                @db.Binary(16) // Which cinema room this perform show?
  start_time     DateTime             @db.Timestamp(0)
  end_time       DateTime             @db.Timestamp(0) // !Must implement auto remove row when end_time is passed (on application or database layer) to trigger casade delete to PickSeat
  translate_type PerformTranslateType @default(value: NONE)
  view_type      PerformViewType      @default(value: V2D)
  price          Decimal              @db.Decimal(10, 2)

  manager   ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  film      Film           @relation(fields: [film_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  room      CinemaRoom     @relation(fields: [cinema_room_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  payments  Payment[]
  pickseats PickSeat[]

  @@map("perform")
}

model Payment {
  id           Bytes         @id @db.Binary(16)
  account_id   Bytes         @unique @db.Binary(16) // unique because one account only have one payment (safe)
  perform_id   Bytes         @db.Binary(16) // Which perform this payment belong to? Morelike "the ticket" we bought
  date_created DateTime      @default(now()) @db.Timestamp(0)
  date_expired DateTime      @db.Timestamp(0)
  status       PaymentStatus @default(value: PENDING)

  account Account           @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  perform Perform           @relation(fields: [perform_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  items   ItemsOnPayments[]

  @@map("payment")
}

model CinemaProvider {
  id             Bytes  @id @db.Binary(16)
  name           String @db.VarChar(50)
  logo_url       String @db.VarChar(2083)
  background_url String @db.VarChar(2083)

  ratings  Rating[]  @relation("RatingToCinemaProvider")
  comments Comment[] @relation("CommentToCinemaProvider")
  cinemas  Cinema[]
  items    Item[] // Cinema provider can create items for all cinemas
  films    Film[] // Cinema provider can create films for all cinemas

  @@map("cinemaprovider")
}

model Cinema {
  id          Bytes  @id @db.Binary(16)
  provider_id Bytes  @db.Binary(16)
  name        String @db.VarChar(50)
  address     String @db.VarChar(255)

  provider CinemaProvider      @relation(fields: [provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  rooms    CinemaRoom[]
  managers CinemasOnManagers[]

  @@map("cinema")
}

model CinemaRoom {
  id               Bytes          @id @db.Binary(16)
  cinema_id        Bytes          @db.Binary(16)
  cinema_layout_id Bytes          @db.Binary(16)
  name             String         @db.VarChar(255)
  type             CinemaRoomType

  cinema        Cinema       @relation(fields: [cinema_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  cinema_layout CinemaLayout @relation(fields: [cinema_layout_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  performs      Perform[]

  @@map("cinemaroom")
}

model CinemaLayout {
  id         Bytes @id @db.Binary(16)
  manager_id Bytes @db.Binary(16) // Who create this layout?
  rows       Int   @db.Int // Number of rows
  columns    Int   @db.Int // Number of columns

  manager       ManagerAccount      @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  rooms         CinemaRoom[]
  layout_groups CinemaLayoutGroup[]
  layout_seats  CinemaLayoutSeat[]

  @@map("cinemalayout")
}

model CinemaLayoutGroup {
  id        Bytes  @id @db.Binary(16)
  layout_id Bytes  @db.Binary(16)
  name      String @db.VarChar(255)
  color     Int    @db.Int
  price     Decimal @db.Decimal(10, 2)

  layout       CinemaLayout       @relation(fields: [layout_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  layout_seats CinemaLayoutSeat[]

  @@map("cinemalayoutgroup")
}

model CinemaLayoutSeat {
  id        Bytes  @id @db.Binary(16)
  layout_id Bytes  @db.Binary(16) // Which layout this seat belong to?
  group_id  Bytes?  @db.Binary(16) // Which group this seat belong to?
  code      String @db.VarChar(50) // A1, A2, A3, B1, B2, B3, ...
  available Boolean @default(true) @db.Bit(1)

  layout       CinemaLayout      @relation(fields: [layout_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  group        CinemaLayoutGroup? @relation(fields: [group_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  layout_seats PickSeat[]

  @@unique([layout_id, code]) // One layout can only have one seat with same code
  @@map("cinemalayoutseat")
}

model Comment {
  id                      Bytes  @id @db.Binary(16)
  account_id              Bytes  @db.Binary(16)
  dest_film_id            Bytes? @db.Binary(16)
  dest_comment_id         Bytes? @db.Binary(16)
  dest_cinema_provider_id Bytes? @db.Binary(16)

  body String      @db.VarChar(300)
  type CommentType

  account              Account         @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ratings              Rating[]        @relation("RatingToComment")
  comments             Comment[]       @relation("CommentToComment")
  dest_film            Film?           @relation("CommentToFilm", fields: [dest_film_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_comment         Comment?        @relation("CommentToComment", fields: [dest_comment_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_cinema_provider CinemaProvider? @relation("CommentToCinemaProvider", fields: [dest_cinema_provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("comment")
}

model Rating {
  id                      Bytes      @id @db.Binary(16)
  account_id              Bytes      @db.Binary(16)
  type                    RatingType
  score                   Float      @db.Float
  dest_cinema_provider_id Bytes?     @db.Binary(16)
  dest_film_id            Bytes?     @db.Binary(16)
  dest_comment_id         Bytes?     @db.Binary(16)

  account              Account         @relation(fields: [account_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_film            Film?           @relation("RatingToFilm", fields: [dest_film_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_cinema_provider CinemaProvider? @relation("RatingToCinemaProvider", fields: [dest_cinema_provider_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  dest_comment         Comment?        @relation("RatingToComment", fields: [dest_comment_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // One dest can only have one rating from same account
  @@unique([account_id, dest_cinema_provider_id])
  @@unique([account_id, dest_film_id])
  @@unique([account_id, dest_comment_id])
  @@map("rating")
}

model FilmsOnTags {
  film_id Bytes  @db.Binary(16)
  tag_id  String @db.VarChar(255)

  film Film @relation(fields: [film_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  tag  Tag  @relation(fields: [tag_id], references: [name], onDelete: Cascade, onUpdate: Cascade)

  @@id([film_id, tag_id])
  @@map("_film_tag")
}

model ItemsOnPayments {
  item_id    Bytes @db.Binary(16)
  payment_id Bytes @db.Binary(16)

  item    Item    @relation(fields: [item_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  payment Payment @relation(fields: [payment_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([item_id, payment_id])
  @@map("_item_payment")
}

model CinemasOnManagers {
  cinema_id  Bytes @db.Binary(16)
  manager_id Bytes @db.Binary(16)

  cinema  Cinema         @relation(fields: [cinema_id], references: [id], onDelete: Cascade, onUpdate: Cascade)
  manager ManagerAccount @relation(fields: [manager_id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([cinema_id, manager_id])
  @@map("_cinema_manager")
}

enum CinemaRoomType {
  NORMAL
  VIP
  DELUXE
}

enum CommentType {
  FILM
  CINEMA_PROVIDER
  COMMENT
}

enum AccountRole {
  USER
  MANAGER
  SUPERADMIN
}

enum PaymentStatus {
  PENDING
  RESOLVED
}

enum PerformTranslateType {
  SUBTITLE
  DUBBING
  NONE
}

enum PerformViewType {
  V2D
  V3D
  IMAX
}

enum RatingType {
  FILM
  CINEMA_PROVIDER
  COMMENT
}
